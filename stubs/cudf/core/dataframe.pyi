import cudf
import numba
import pandas as pd
import pyarrow as pa
import pylibcudf as plc
from _typeshed import Incomplete
from collections import abc
from collections.abc import Callable as Callable, Generator
from cudf._typing import ColumnLike as ColumnLike, Dtype as Dtype, NotImplementedType as NotImplementedType
from cudf.api.extensions import no_default as no_default
from cudf.api.types import is_dict_like as is_dict_like, is_dtype_equal as is_dtype_equal, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype
from cudf.core import column as column, df_protocol as df_protocol, indexing_utils as indexing_utils, reshape as reshape
from cudf.core._compat import PANDAS_LT_300 as PANDAS_LT_300
from cudf.core.buffer import acquire_spill_lock as acquire_spill_lock, as_buffer as as_buffer
from cudf.core.column import CategoricalColumn as CategoricalColumn, ColumnBase as ColumnBase, StructColumn as StructColumn, as_column as as_column, column_empty as column_empty, concat_columns as concat_columns
from cudf.core.column.categorical import as_unsigned_codes as as_unsigned_codes
from cudf.core.column_accessor import ColumnAccessor as ColumnAccessor
from cudf.core.copy_types import BooleanMask as BooleanMask
from cudf.core.groupby.groupby import DataFrameGroupBy as DataFrameGroupBy, groupby_doc_template as groupby_doc_template
from cudf.core.index import BaseIndex as BaseIndex, RangeIndex as RangeIndex, ensure_index as ensure_index
from cudf.core.indexed_frame import IndexedFrame as IndexedFrame, _FrameIndexer, doc_reset_index_template as doc_reset_index_template
from cudf.core.join import Merge as Merge, MergeSemi as MergeSemi
from cudf.core.missing import NA as NA
from cudf.core.multiindex import MultiIndex as MultiIndex
from cudf.core.resample import DataFrameResampler as DataFrameResampler
from cudf.core.series import Series as Series
from cudf.errors import MixedTypeError as MixedTypeError
from cudf.utils import applyutils as applyutils, docutils as docutils, ioutils as ioutils, queryutils as queryutils
from cudf.utils.docutils import copy_docstring as copy_docstring
from cudf.utils.dtypes import can_convert_to_column as can_convert_to_column, cudf_dtype_from_pydata_dtype as cudf_dtype_from_pydata_dtype, find_common_type as find_common_type, is_column_like as is_column_like, min_signed_type as min_signed_type
from cudf.utils.performance_tracking import _performance_tracking
from cudf.utils.utils import GetAttrGetItemMixin as GetAttrGetItemMixin
from typing import Any, Literal
from typing_extensions import Self

class _DataFrameIndexer(_FrameIndexer):
    def __getitem__(self, arg): ...
    def __setitem__(self, key, value) -> None: ...

class _DataFrameLocIndexer(_DataFrameIndexer): ...
class _DataFrameAtIndexer(_DataFrameLocIndexer): ...

class _DataFrameIlocIndexer(_DataFrameIndexer):
    def __getitem__(self, arg): ...

class _DataFrameiAtIndexer(_DataFrameIlocIndexer): ...

class DataFrame(IndexedFrame, GetAttrGetItemMixin):
    @_performance_tracking
    def __init__(self, data=None, index=None, columns=None, dtype=None, copy=None, nan_as_null=...) -> None: ...
    def serialize(self): ...
    @classmethod
    def deserialize(cls, header, frames): ...
    @property
    @_performance_tracking
    def shape(self): ...
    @property
    def dtypes(self): ...
    @property
    def ndim(self) -> int: ...
    def __dir__(self): ...
    def __setattr__(self, key, col) -> None: ...
    @_performance_tracking
    def __getitem__(self, arg): ...
    @_performance_tracking
    def __setitem__(self, arg, value) -> None: ...
    def __delitem__(self, name) -> None: ...
    @_performance_tracking
    def memory_usage(self, index: bool = True, deep: bool = False) -> cudf.Series: ...
    @_performance_tracking
    def __array_function__(self, func, types, args, kwargs): ...
    def __arrow_c_stream__(self, requested_schema=None): ...
    @_performance_tracking
    def assign(self, **kwargs: Callable[[Self], Any] | Any): ...
    def astype(self, dtype, copy: bool = False, errors: Literal['raise', 'ignore'] = 'raise'): ...
    @classmethod
    @_performance_tracking
    def from_dict(cls, data: dict, orient: str = 'columns', dtype: Dtype | None = None, columns: list | None = None) -> DataFrame: ...
    @_performance_tracking
    def to_dict(self, orient: str = 'dict', into: type[dict] = ..., index: bool = True) -> dict | list[dict]: ...
    @_performance_tracking
    def scatter_by_map(self, map_index, map_size=None, keep_index: bool = True, debug: bool = False): ...
    @_performance_tracking
    def update(self, other, join: str = 'left', overwrite: bool = True, filter_func=None, errors: str = 'ignore') -> None: ...
    @_performance_tracking
    def __iter__(self): ...
    @_performance_tracking
    def __contains__(self, item) -> bool: ...
    @_performance_tracking
    def items(self) -> Generator[Incomplete]: ...
    @_performance_tracking
    def equals(self, other) -> bool: ...
    @property
    def iat(self): ...
    @property
    def at(self): ...
    @property
    @_performance_tracking
    def columns(self): ...
    @columns.setter
    @_performance_tracking
    def columns(self, columns) -> None: ...
    @_performance_tracking
    def reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy: bool = True, level=None, fill_value=..., limit=None, tolerance=None): ...
    @_performance_tracking
    def set_index(self, keys, drop: bool = True, append: bool = False, inplace: bool = False, verify_integrity: bool = False): ...
    @_performance_tracking
    def fillna(self, value=None, method=None, axis=None, inplace: bool = False, limit=None): ...
    @_performance_tracking
    def where(self, cond, other=None, inplace: bool = False, axis=None, level=None): ...
    def reset_index(self, level=None, drop: bool = False, inplace: bool = False, col_level: int = 0, col_fill: str = '', allow_duplicates: bool = False, names: abc.Hashable | abc.Sequence[abc.Hashable] | None = None): ...
    @_performance_tracking
    def insert(self, loc, column, value, allow_duplicates: bool = False, nan_as_null=...): ...
    @property
    @_performance_tracking
    def axes(self): ...
    def diff(self, periods: int = 1, axis: int = 0): ...
    @_performance_tracking
    def drop_duplicates(self, subset=None, keep: str = 'first', inplace: bool = False, ignore_index: bool = False): ...
    @_performance_tracking
    def pop(self, item): ...
    @_performance_tracking
    def rename(self, mapper=None, index=None, columns=None, axis: int = 0, copy: bool = True, inplace: bool = False, level=None, errors: str = 'ignore'): ...
    @_performance_tracking
    def add_prefix(self, prefix, axis=None): ...
    @_performance_tracking
    def add_suffix(self, suffix, axis=None): ...
    @_performance_tracking
    def agg(self, aggs, axis=None): ...
    @_performance_tracking
    def nlargest(self, n, columns, keep: str = 'first'): ...
    def nsmallest(self, n, columns, keep: str = 'first'): ...
    @_performance_tracking
    def swaplevel(self, i: int = -2, j: int = -1, axis: int = 0): ...
    @_performance_tracking
    def transpose(self): ...
    T: Incomplete
    @_performance_tracking
    def melt(self, id_vars=None, value_vars=None, var_name=None, value_name: str = 'value', col_level=None, ignore_index: bool = True): ...
    @_performance_tracking
    def merge(self, right, how: str = 'inner', on=None, left_on=None, right_on=None, left_index: bool = False, right_index: bool = False, sort: bool = False, suffixes=('_x', '_y'), indicator: bool = False, validate=None): ...
    @_performance_tracking
    def join(self, other, on=None, how: str = 'left', lsuffix: str = '', rsuffix: str = '', sort: bool = False, validate: str | None = None): ...
    @_performance_tracking
    def groupby(self, by=None, axis: int = 0, level=None, as_index: bool = True, sort=..., group_keys: bool = False, observed: bool = True, dropna: bool = True): ...
    def query(self, expr, local_dict=None): ...
    @_performance_tracking
    def apply(self, func, axis: int = 1, raw: bool = False, result_type=None, args=(), by_row: Literal[False, 'compat'] = 'compat', engine: Literal['python', 'numba'] = 'python', engine_kwargs: dict[str, bool] | None = None, **kwargs): ...
    def applymap(self, func: Callable[[Any], Any], na_action: str | None = None, **kwargs) -> DataFrame: ...
    def map(self, func: Callable[[Any], Any], na_action: str | None = None, **kwargs) -> DataFrame: ...
    @_performance_tracking
    def apply_rows(self, func, incols, outcols, kwargs, pessimistic_nulls: bool = True, cache_key=None): ...
    @_performance_tracking
    def apply_chunks(self, func, incols, outcols, kwargs=None, pessimistic_nulls: bool = True, chunks=None, blkct=None, tpb=None): ...
    @_performance_tracking
    def partition_by_hash(self, columns, nparts: int, keep_index: bool = True) -> list[DataFrame]: ...
    def info(self, verbose=None, buf=None, max_cols=None, memory_usage=None, null_counts=None): ...
    @_performance_tracking
    def describe(self, percentiles=None, include=None, exclude=None): ...
    @_performance_tracking
    def to_pandas(self, *, nullable: bool = False, arrow_type: bool = False) -> pd.DataFrame: ...
    @classmethod
    @_performance_tracking
    def from_pandas(cls, dataframe, nan_as_null=...): ...
    @classmethod
    @_performance_tracking
    def from_arrow(cls, table): ...
    @_performance_tracking
    def to_arrow(self, preserve_index=None) -> pa.Table: ...
    @_performance_tracking
    def to_records(self, index: bool = True, column_dtypes=None, index_dtypes=None): ...
    @classmethod
    @_performance_tracking
    def from_records(cls, data, index=None, exclude=None, columns=None, coerce_float: bool = False, nrows: int | None = None, nan_as_null: bool = False): ...
    @_performance_tracking
    def interpolate(self, method: str = 'linear', axis: int = 0, limit=None, inplace: bool = False, limit_direction=None, limit_area=None, downcast=None, **kwargs): ...
    @_performance_tracking
    def quantile(self, q: float = 0.5, axis: int = 0, numeric_only: bool = True, interpolation=None, method: str = 'single', columns=None, exact: bool = True): ...
    @_performance_tracking
    def isin(self, values): ...
    @_performance_tracking
    def count(self, axis: int = 0, numeric_only: bool = False): ...
    @_performance_tracking
    def mode(self, axis: int = 0, numeric_only: bool = False, dropna: bool = True): ...
    @_performance_tracking
    def all(self, axis: int = 0, bool_only=None, skipna: bool = True, **kwargs): ...
    @_performance_tracking
    def any(self, axis: int = 0, bool_only=None, skipna: bool = True, **kwargs): ...
    @_performance_tracking
    def select_dtypes(self, include=None, exclude=None): ...
    def to_parquet(self, path, engine: str = 'cudf', compression: str = 'snappy', index=None, partition_cols=None, partition_file_name=None, partition_offsets=None, statistics: str = 'ROWGROUP', metadata_file_path=None, int96_timestamps: bool = False, row_group_size_bytes=None, row_group_size_rows=None, max_page_size_bytes=None, max_page_size_rows=None, storage_options=None, return_metadata: bool = False, use_dictionary: bool = True, header_version: str = '1.0', skip_compression=None, column_encoding=None, column_type_length=None, output_as_binary=None, *args, **kwargs): ...
    def to_feather(self, path, *args, **kwargs) -> None: ...
    def to_csv(self, path_or_buf=None, sep: str = ',', na_rep: str = '', columns=None, header: bool = True, index: bool = True, encoding=None, compression=None, lineterminator=None, chunksize=None, storage_options=None): ...
    def to_orc(self, fname, compression: str = 'snappy', statistics: str = 'ROWGROUP', stripe_size_bytes=None, stripe_size_rows=None, row_index_stride=None, cols_as_map_type=None, storage_options=None, index=None): ...
    @_performance_tracking
    def stack(self, level: int = -1, dropna=..., future_stack: bool = False) -> DataFrame | Series: ...
    @_performance_tracking
    def cov(self, min_periods=None, ddof: int = 1, numeric_only: bool = False): ...
    def corr(self, method: str = 'pearson', min_periods=None, numeric_only: bool = False): ...
    @_performance_tracking
    def to_struct(self, name=None): ...
    @_performance_tracking
    def keys(self): ...
    def itertuples(self, index: bool = True, name: str = 'Pandas') -> None: ...
    def iterrows(self) -> None: ...
    @_performance_tracking
    def pivot(self, *, columns, index=..., values=...): ...
    @_performance_tracking
    def pivot_table(self, values=None, index=None, columns=None, aggfunc: str = 'mean', fill_value=None, margins: bool = False, dropna=None, margins_name: str = 'All', observed: bool = False, sort: bool = True): ...
    @_performance_tracking
    def unstack(self, level: int = -1, fill_value=None, sort: bool = True): ...
    @_performance_tracking
    def explode(self, column, ignore_index: bool = False): ...
    def pct_change(self, periods: int = 1, fill_method=..., limit=..., freq=None, **kwargs): ...
    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True): ...
    def nunique(self, axis: int = 0, dropna: bool = True) -> Series: ...
    @_performance_tracking
    def interleave_columns(self): ...
    @_performance_tracking
    def eval(self, expr: str, inplace: bool = False, **kwargs): ...
    def value_counts(self, subset=None, normalize: bool = False, sort: bool = True, ascending: bool = False, dropna: bool = True): ...
    @_performance_tracking
    def to_pylibcudf(self, copy: bool = False) -> tuple[plc.Table, dict]: ...
    @classmethod
    @_performance_tracking
    def from_pylibcudf(cls, table: plc.Table, metadata: dict) -> Self: ...

def from_dataframe(df, allow_copy: bool = False) -> DataFrame: ...
def make_binop_func(op, postprocess=None): ...
@_performance_tracking
def from_pandas(obj, nan_as_null=...): ...
@_performance_tracking
def merge(left, right, *args, **kwargs): ...

merge_doc: Incomplete
idx: Incomplete

def extract_col(df, col): ...
